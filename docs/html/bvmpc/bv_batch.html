<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>bvmpc.bv_batch API documentation</title>
<meta name="description" content="This module holds functions related to running batch operations." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>bvmpc.bv_batch</code></h1>
</header>
<section id="section-intro">
<p>This module holds functions related to running batch operations.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This module holds functions related to running batch operations.&#34;&#34;&#34;
import os
import numpy as np
import pandas as pd
import math

import seaborn as sns
import matplotlib.gridspec as gridspec
import matplotlib.pyplot as plt

from bvmpc.bv_file import extract_sessions
import bvmpc.bv_analyse as bv_an
import bvmpc.bv_plot as bv_plot
import bvmpc.bv_utils


def struc_timeline(sub_list, in_dir):
    &#34;&#34;&#34; Structure sessions into a pandas dataframe based on trials
    Returns 2 outputs: grp_timeline_df, time_df_sub
        grp_timeline_df - array of pandas dataframe across time based on session
        grp_timeline_df_sub     - list denoting subject corresponding to each df
    &#34;&#34;&#34;
    # Initialize group variables
    grp_timeline_df = []
    grp_timeline_df_sub = []

    for sub in sub_list:
        s_grp = extract_sessions(in_dir, sub)
        # Initialize column arrays
        d_list, t_list, sub_list, s_idx_list, r_list, s_list = [], [], [], [], [], []
        err_FR_list, err_FI_list = [], []
        rw_FR_list, rw_FI_list, dr_list = [], [], []
        ratio_list, interval_list = [], []
        sch_list, sch_rw_list, sch_err_list, sch_dr_list = [], [], [], []

        for i, s in enumerate(s_grp):
            subject = s.get_metadata(&#39;subject&#39;)
            date = s.get_metadata(&#34;start_date&#34;).replace(&#34;/&#34;, &#34;-&#34;)[:5]
            session_type = s.get_metadata(&#39;name&#39;)
            time = s.get_metadata(&#39;start_time&#39;)
            stage = session_type[:2].replace(
                &#39;_&#39;, &#39;&#39;)  # Obtain stage number w/o _
            timestamps = s.get_arrays()
            pell_ts = timestamps[&#34;Reward&#34;]
            dpell_bool = np.diff(pell_ts) &lt; 0.5
            dpell_idx = np.nonzero(dpell_bool)[0]
            reward_times = s.get_rw_ts()

            # Initialize variables used per session
            ratio, interval, sch, sch_err, sch_rw, sch_dr = [], [], [], [], [], []
            err_FI, err_FR, rw_FI, rw_FR = [], [], [], []

            ratio = s.get_ratio()
            interval = s.get_interval()
            # Stage specific variables
            if stage == &#39;5a&#39;:
                s_name = &#39;R&#39; + str(ratio)
                ratio = s_name
                rw_FR = len(reward_times)
            elif stage == &#39;5b&#39;:
                s_name = &#39;I&#39; + str(interval)
                interval = s_name
                rw_FI = len(reward_times)
            else:
                s_name = stage.replace(&#39;_&#39;, &#39;&#39;).replace(&#39;2&#39;, &#39;M&#39;).replace(
                    &#39;3&#39;, &#39;Lh&#39;).replace(&#39;4&#39;, &#39;Lt&#39;).replace(
                    &#39;6&#39;, &#39;B1&#39;).replace(&#39;7&#39;, &#39;B2&#39;)
            if &#39;B&#39; in s_name:
                rw_FI, rw_FR = 0, 0
                ratio = &#39;R&#39; + str(ratio)
                interval = &#39;I&#39; + str(interval)
                norm_r_ts, _, norm_err_ts, norm_dr_ts, _ = s.split_sess(
                    all_levers=True)
                sch_type = s.get_arrays(&#39;Trial Type&#39;)
                # Error related variables
                if s_name == &#39;B2&#39;:
                    err_FI, err_FR = 0, 0
                    for i, err in enumerate(norm_err_ts):
                        if sch_type[i] == 1:
                            err_FR = + len(err)
                        elif sch_type[i] == 0:
                            err_FI += len(err)
                        sch_err.append(len(err))
                else:
                    err_FR = []
                    err_FI = []

                # Reward related variables
                for i, (rw, dr) in enumerate(zip(norm_r_ts, norm_dr_ts)):
                    if sch_type[i] == 1:
                        rw_FR += len(rw)
                        sch.append(&#39;FR&#39;)
                        sch_dr.append([])
                    elif sch_type[i] == 0:
                        rw_FI += len(rw)
                        sch.append(&#39;FI&#39;)
                        sch_dr.append(len(dr))
                    sch_rw.append(len(rw))

            # Update list arrays with new session
            d_list.append(date)
            t_list.append(time)
            s_idx_list.append(&#39;S&#39; + stage[0])
            s_list.append(s_name)
            r_list.append(len(pell_ts))
            dr_list.append(len(dpell_idx))
            interval_list.append(interval)
            ratio_list.append(ratio)
            sch_list.append(sch)
            sch_rw_list.append(sch_rw)
            sch_err_list.append(sch_err)
            sch_dr_list.append(sch_dr)
            rw_FI_list.append(rw_FI)
            rw_FR_list.append(rw_FR)
            err_FI_list.append(err_FI)
            err_FR_list.append(err_FR)
        sub_list = np.full(len(d_list), sub, dtype=int)

        timeline_dict = {
            &#39;Subject&#39;: sub_list,
            &#39;Date&#39;: d_list,
            &#39;Start Time&#39;: t_list,
            &#39;Stage Idx&#39;: s_idx_list,  # eg. S2, S5, S7 ...
            &#39;Stage&#39;: s_list,  # eg. M, Lt, R8, I30, B1
            &#39;Total Rewards&#39;: r_list,
            &#39;Double Rewards&#39;: dr_list,
            &#39;Interval&#39;: interval_list,
            &#39;Ratio&#39;: ratio_list,
            &#39;Schedule Blocks&#39;: sch_list,
            &#39;Schedule Rw&#39;: sch_rw_list,
            &#39;Schedule Err&#39;: sch_err_list,
            &#39;Schedule DRw&#39;: sch_dr_list,
            &#39;FI Corr&#39;: rw_FI_list,
            &#39;FR Corr&#39;: rw_FR_list,
            &#39;FI Err&#39;: err_FI_list,
            &#39;FR Err&#39;: err_FR_list
        }
        timeline_df = pd.DataFrame(timeline_dict)
        grp_timeline_df.append(timeline_df)
        grp_timeline_df_sub.append(subject)

    return grp_timeline_df, grp_timeline_df_sub


def plot_batch_sessions(start_dir, sub_list, start_date, end_date, plt_flags, sub_colors_dict):
    out_dir = os.path.join(start_dir, &#34;Plots&#34;, &#34;Current&#34;)
    bvmpc.bv_utils.make_dir_if_not_exists(out_dir)

    if plt_flags[&#34;raster&#34;] == 1 or plt_flags[&#34;hist&#34;] == 1:
        # Path join only present in plot_sessions
        in_dir = os.path.join(start_dir, &#34;hdf5&#34;)

        # Default conversion of date based on start_date and end_date range
        d = []
        for single_date in bvmpc.bv_utils.daterange(start_date, end_date):
            d.append(single_date.isoformat()[-5:])

        print(&#39;Extracting sessions on {} for subjects {}...&#39;.format(d, sub_list))
        s_grp = extract_sessions(in_dir, sub_list, d_list=d)

        # splits s_grp into groups of 4
        plot_set = bvmpc.bv_utils.chunks(s_grp, 4)

        for j, plot_grp in enumerate(plot_set):
            # Figure Initialization
            n = len(plot_grp)
            if n &gt; 4:
                print(&#39;Too many plots&#39;)
                quit()
            elif n &gt; 2:
                rows, cols = [4, 4 * math.ceil(n / 2)]
            else:
                rows, cols = [2 * n, 4 * math.ceil(n / 2)]

            # Initializes GridFig Obj
            gf = bv_plot.GridFig(rows, cols, wspace=0.5, hspace=0.5)
            # fig = gf.get_fig()
            # size_multiplier = 5
            # fig = plt.figure(
            #     figsize=(cols * size_multiplier, rows * size_multiplier),
            #     tight_layout=False)
            # gs = gridspec.GridSpec(rows, cols, wspace=0.5, hspace=0.5)

            df_sub, df_date, df_stage = [], [], []  # Initialize plot naming parameters

            plotting_sub = []
            for i, s in enumerate(plot_grp):  # Iterate through groups to plot rasters
                # plot naming parameters
                df_sub.append(s.get_metadata(&#39;subject&#39;))
                df_date.append(s.get_metadata(
                    &#39;start_date&#39;).replace(&#39;/&#39;, &#39;_&#39;)[:5])
                df_stage.append(s.get_stage())

                # 2x2 plotting axes
                k = (i % 2) * 2
                if plt_flags[&#34;raster&#34;] == 1:
                    ax = gf.get_multi_ax(
                        k, k + 2, 4 * int(i / 2), 4 * math.ceil((i + 1) / 2))
                    bv_an.plot_raster_trials(
                        s, ax, sub_colors_dict, align=[0, 0, 1, 0])
                    plot_type = &#39;Raster_&#39;  # Plot name for saving

                if plt_flags[&#34;hist&#34;] == 1:
                    if not plotting_sub == s.get_metadata(&#39;subject&#39;):
                        ax = gf.get_multi_ax(
                            k, k + 2, 4 * int(i / 2), 4 * math.ceil((i + 1) / 2))
                        plotting_sub = s.get_metadata(&#39;subject&#39;)
                        loop = 1
                    bv_an.trial_length_hist(s, ax, loop, sub_colors_dict)
                    plot_type = &#39;Hist_&#39;  # Plot name for saving
                    loop += 1

            # Save Figure
            # plt.subplots_adjust(top=0.85)
            # fig.suptitle((&#39;Subject &#39; + subject + &#39; Performance&#39;),
            #                 color=mycolors(subject), fontsize=30)

            # date_p = sorted(set(df_date))
            # sub_p = sorted(set(df_sub))
            # stage_p = sorted(set(df_stage))
            # out_name = plot_type + str(date_p) + &#39;_&#39; + str(sub_p) + &#39;_&#39; + str(stage_p) + &#39;_&#39; + str(j)
            # out_name += &#34;.png&#34;
            # print(&#34;Saved figure to {}&#34;.format(
            #     os.path.join(out_dir, out_name)))
            # bv_plot.savefig(fig, os.path.join(out_dir, out_name))
            # plt.close()
            gf.save_fig(df_date, df_sub, df_stage, plot_type, out_dir, j)

    # plot cumulative response graphs
    if plt_flags[&#34;summary&#34;] == 1:
        for single_date in bvmpc.bv_utils.daterange(start_date, end_date):
            d = [single_date.isoformat()[-5:]]
            # plot_sessions(start_dir, d, sub, summary=True, single=True,
            #               corr_only=True, scd=sub_colors_dict)  # Single animal breakdown
            # Group with corr_only breakdown
            plot_sessions(start_dir, d, sub_list, summary=True,
                          single=False, corr_only=True, scd=sub_colors_dict)
            # plot_sessions(start_dir, d, sub, summary=True, single=False, corr_only=False, scd=sub_colors_dict)  # Group with complete breakdown

        # plot all 4 timeline types
    if plt_flags[&#34;timeline&#34;] == 1:
        print(&#34;Plotting Timeline...&#34;)
        d = [end_date.isoformat()[-5:]]
        in_dir = os.path.join(start_dir, &#34;hdf5&#34;)
        single = False  # plots seperate graphs for each animal if True
        show_date = True  # Sets x-axis as dates if True
        details = False
        recent = False
        if not single:
            plot_limit = 4
            sub_list = bvmpc.bv_utils.split_list(sub_list, plot_limit)
            for l in sub_list:
                timeline_plot(l, in_dir, out_dir, single_plot=single, det_err=False, det_corr=False,
                              recent=recent, show_date=show_date, details=details, sub_colors_dict=sub_colors_dict)
        else:
            # Plots timeline for specified subjects
            timeline_plot(sub_list, in_dir, out_dir, single_plot=single, det_err=False, det_corr=False,
                          recent=recent, show_date=show_date, details=details, sub_colors_dict=sub_colors_dict)


def plot_sessions(
        start_dir, d_list, sub_list,
        summary=False, single=False, timeline=False,
        details=False, det_err=False, det_corr=False,
        recent=False, show_date=False, int_only=False,
        corr_only=False, scd=None):  # TODO Split timeline and plotting into seperate functions
    &#39;&#39;&#39; Plots session summaries
    summary : bool, False
        Optional. Plots all sessions in a single plot, up to 6
    single : bool, False
        Optional. Plots single session summaries with breakdown of single blocks
    int_only : bool, False
        Optional. Plots only interval trials in zoomed schedule plot
    corr_only : bool, False
        Optional. Plots seperate summary plot with correct only trials
    scd : dict, None
        dict of Sub : color
        Used to assign color to plot title.
    &#39;&#39;&#39;
    s_list = [&#39;4&#39;, &#39;5a&#39;, &#39;5b&#39;, &#39;6&#39;, &#39;7&#39;]

    in_dir = os.path.join(start_dir, &#34;hdf5&#34;)
    out_dir = os.path.join(start_dir, &#34;Plots&#34;, &#34;Current&#34;)
    bvmpc.bv_utils.make_dir_if_not_exists(out_dir)

    if summary and not corr_only:
        #  extracts hdf5 session based on specification
        max_plot = 4  # Set max plots per figure
        s_grp = extract_sessions(in_dir, sub_list, s_list, d_list)
        if s_grp == []:
            return print(&#34;***No Files Extracted***&#34;)
        idx = 0
        if len(s_grp) &gt; max_plot:
            j = 0
            s_grp_split = []
            s_grp_idx = np.arange(len(s_grp))
            for i in s_grp_idx[max_plot - 1::max_plot]:
                s_grp_split.append(s_grp[j:i + 1])
                j = i + 1

            mv = len(s_grp) % max_plot
            if mv != 0:
                s_grp_split.append(s_grp[-mv:])
            for s_grp in s_grp_split:
                idx += 1
                sum_plot(s_grp, idx, out_dir)
        else:
            sum_plot(s_grp, idx, out_dir)

    if summary and corr_only:
        # plots corr_only plots
        max_plot = 4  # Set max plots per figure
        s_grp = extract_sessions(in_dir, sub_list, s_list, d_list)
        if s_grp == []:
            return print(&#34;***No Files Extracted***&#34;)

        idx = 0
        if len(s_grp) &gt; max_plot:
            j = 0
            s_grp_split = []
            s_grp_idx = np.arange(len(s_grp))
            for i in s_grp_idx[max_plot - 1::max_plot]:
                s_grp_split.append(s_grp[j:i + 1])
                j = i + 1

            mv = len(s_grp) % max_plot
            if mv != 0:
                s_grp_split.append(s_grp[-mv:])
            for s_grp in s_grp_split:
                idx += 1
                sum_plot(s_grp, idx, out_dir, corr_only=True)
        else:
            sum_plot(s_grp, idx, out_dir, corr_only=True)

    if single and summary:
        # Single Subject Plots
        idx = 0
        for sub in sub_list:
            s_grp = extract_sessions(in_dir, sub, s_list, d_list)
            if s_grp == []:
                return print(&#34;***No Files Extracted***&#34;)
            s_passed = []
            d_passed = []
            for s in s_grp:
                stage = s.get_metadata(&#39;name&#39;)[:2].replace(&#39;_&#39;, &#39;&#39;)
                s_passed.append(stage)
                date = s.get_metadata(&#34;start_date&#34;).replace(&#34;/&#34;, &#34;-&#34;)
                d_passed.append(date[:5])
                subject = s.get_metadata(&#39;subject&#39;)
            if &#39;7&#39; in s_passed:
                gf = bv_plot.GridFig(len(s_grp), 4)
                fig = gf.get_fig()
                if len(s_grp) == 1:
                    fig.tight_layout(rect=[0, 0.03, 0.8, 0.95])
                for i, s in enumerate(s_grp):
                    ax1 = gf.get_next()
                    bv_an.cumplot(s, out_dir, ax1, int_only,
                                  zoom=False, zoom_sch=False)
                    ax2 = gf.get_next()
                    bv_an.cumplot(s, out_dir, ax2, int_only, zoom=False, zoom_sch=True,
                                  plot_error=False, plot_all=True)
                    ax3 = gf.get_next()
                    bv_an.cumplot(s, out_dir, ax3, int_only, zoom=False, zoom_sch=True,
                                  plot_error=False, plot_all=False)
                    ax4 = gf.get_next()
                    bv_an.cumplot(s, out_dir, ax4, int_only, zoom=False, zoom_sch=True,
                                  plot_error=True, plot_all=False)
                plt.subplots_adjust(top=0.85)
                if scd == None:
                    color = &#34;k&#34;
                else:
                    color = bvmpc.bv_utils.mycolors(sub, scd)
                fig.suptitle((&#39;Subject &#39; + subject + &#39; Performance&#39;),
                             color=color, fontsize=30)

                # # Seperate plots w line
                # ax1.hlines(1.13, -0, 4.9, clip_on=False,
                #             transform=ax1.transAxes, linewidth=0.7)
                s_print = np.array_str(np.unique(np.array(s_passed)))
                d_print = np.array_str(np.unique(np.array(d_passed)))
                out_name = &#34;Sum_&#34; + subject + &#34;_&#34; + d_print + &#34;_&#34; + s_print + &#34;.png&#34;
                bv_plot.savefig(fig, os.path.join(out_dir, out_name))
            else:
                sum_plot(s_grp, idx, out_dir, single=single)


def sum_plot(s_grp, idx, out_dir, zoom=True, single=False,
             int_only=False, corr_only=False):
    &#34;&#34;&#34; zoom:   if True, divides session into blocks and plots each block as individual lines.

    &#34;&#34;&#34;
    # Plots summary of day
    if zoom:
        print(&#39;zoomed&#39;)
        if len(s_grp) &gt; 2:
            cols = 2 * math.ceil(len(s_grp) / 2)
            rows = 2
        else:
            rows = len(s_grp)
            cols = 2
    else:
        if len(s_grp) &gt; 4:
            rows = math.ceil(len(s_grp) / 4)
            cols = 4
        else:
            cols = len(s_grp)
            rows = 1
    gf = bv_plot.GridFig(rows, cols)
    fig = gf.get_fig()
    s_passed = []
    d_passed = []

    for _, s in enumerate(s_grp):
        subject = s.get_metadata(&#39;subject&#39;)
        stage = s.get_metadata(&#39;name&#39;)[:2].replace(&#39;_&#39;, &#39;&#39;)
        date = s.get_metadata(&#34;start_date&#34;).replace(&#34;/&#34;, &#34;-&#34;)
        s_passed.append(stage)
        d_passed.append(date[:5])

        if zoom:
            ax1 = gf.get_next_snake()
        else:
            ax1 = gf.get_next()

        if corr_only and stage == &#39;7&#39;:
            bv_an.cumplot(s, out_dir, ax1, int_only, zoom=False,
                          zoom_sch=False, plot_all=False)
        else:
            bv_an.cumplot(s, out_dir, ax1, int_only, zoom=False,
                          zoom_sch=False)

        if stage == &#39;2&#39; or stage == &#39;3&#39; or stage == &#39;4&#39;:
            IRT = True
        elif stage == &#39;5a&#39; or stage == &#39;5b&#39;:
            IRT = True  # Change to False for zoomed plot instead of IRT
        else:
            IRT = False

        if IRT:
            ax2 = gf.get_next_snake()
            bv_an.IRT(s, out_dir, ax2)
        elif zoom:
            ax2 = gf.get_next_snake()
            if corr_only and stage == &#39;7&#39;:
                bv_an.cumplot(s, out_dir, ax2, int_only, zoom=False, zoom_sch=True,
                              plot_error=False, plot_all=False)
            else:
                bv_an.cumplot(s, out_dir, ax2, int_only, zoom=False, zoom_sch=True,
                              plot_error=False, plot_all=True)
        plt.subplots_adjust(top=0.85)
    d_print = np.array_str(np.unique(np.array(d_passed)))
    d_title = np.array2string(np.unique(np.array(d_passed)))
    s_print = np.array_str(np.unique(np.array(s_passed)))

    if single:
        fig.suptitle((&#39;Subject &#39; + subject + &#39; Performance&#39;), fontsize=30)
        out_name = &#34;Sum_&#34; + subject + &#34;_&#34; + d_print + &#34;_&#34; + s_print + &#34;.png&#34;
    elif corr_only and stage == &#39;7&#39;:
        if idx == 0:
            fig.suptitle((&#39;Summary across animals &#39; + d_title +
                          &#39;_Correct Only&#39;), fontsize=30)
            out_name = &#34;Sum_&#34; + d_print + &#34;_&#34; + s_print + &#34;_Corr.png&#34;
        else:
            fig.suptitle((&#39;Summary across animals &#39; + d_title +
                          &#39;_Correct Only&#39; + &#34; p&#34; + str(idx)), fontsize=30)
            out_name = &#34;Sum_&#34; + d_print + &#34;_&#34; + \
                s_print + &#34;_&#34; + str(idx) + &#34;_Corr.png&#34;
    else:
        if idx == 0:
            fig.suptitle((&#39;Summary across animals &#39; + d_title), fontsize=30)
            out_name = &#34;Sum_&#34; + d_print + &#34;_&#34; + s_print + &#34;.png&#34;
        else:
            fig.suptitle((&#39;Summary across animals &#39; +
                          d_title + &#34; p&#34; + str(idx)), fontsize=30)
            out_name = &#34;Sum_&#34; + d_print + &#34;_&#34; + \
                s_print + &#34;_&#34; + str(idx) + &#34;.png&#34;
    print(&#34;Saved figure to {}&#34;.format(
        os.path.join(out_dir, out_name)))
    bv_plot.savefig(fig, os.path.join(out_dir, out_name))
    plt.close()


def timeline_plot(
        sub_list, in_dir, out_dir, single_plot=False,
        det_err=False, det_corr=False, recent=False,
        show_date=True, details=False, sub_colors_dict=None):
    &#34;&#34;&#34;

    Plots total rewards from beginining of first session  

    Arguments:
    det_err - plots error lever presses
    det_cor - plots correct lever presses
    recent - plots recent (determined in code - static) datapoints only
    show_date - plots date as x axis instead of session type
    &#34;&#34;&#34;
    # Plot size
    rows, cols = [len(sub_list), 4]
    size_multiplier = 5
    fig = plt.figure(
        figsize=(cols * size_multiplier, rows * size_multiplier),
        tight_layout=False)
    gs = gridspec.GridSpec(rows, cols, wspace=0.4, hspace=0.5)

    for c, sub in enumerate(sub_list):
        # Plot total pellets across sessions
        s_grp = extract_sessions(in_dir, [sub])
        s_list, r_list, type_list, d_list, box_list, time_list = [], [], [], [], [], []
        err_FR_list, err_FI_list = [], []
        rw_FR_list, rw_FI_list, rw_double_list = [], [], []
        changes, stage_change, dpell_change = [], [], []
        change_idx = []
        prev_ratio, prev_interval, c_ratio, c_interval = [], [], [], []
        dpell_old = []
        prev_name = &#39;2&#39;
        if recent:
            number_sessions_ago = -31  # change value to set number of sessions ago
            s_grp = s_grp[number_sessions_ago:]
        else:
            pass

        for i, s in enumerate(s_grp):
            ratio = s.get_ratio()
            interval = s.get_interval()
            s_type = s.get_metadata(&#39;name&#39;)[:2]
            timestamps = s.get_arrays()

            date = s.get_metadata(&#39;start_date&#39;)  # Display mm/dd/yy
            date = s.get_metadata(&#39;start_date&#39;)[:-3]  # Display mm/dd only
            # date = s.get_metadata(&#39;start_date&#39;).split(&#34;/&#34;)[1]  # Display dd only
            subject = s.get_metadata(&#39;subject&#39;)
            pell_ts = timestamps[&#34;Reward&#34;]
            pell_double = np.nonzero(np.diff(pell_ts) &lt; 0.5)[0]
            reward_times = s.get_rw_ts()
            box = s.get_metadata(&#39;box&#39;)
            # time format - &#34;%H:%M:%S&#34;
            exptime = s.get_metadata(&#39;start_time&#39;)[:2]

            d_list.append(date)
            box_list.append(box)
            time_list.append(exptime)

            if len(pell_double):
                dpell_change = 1
            if s_type == &#39;5a&#39;:
                s_name = &#39;R&#39; + str(ratio)
                c_ratio = s_name
            elif s_type == &#39;5b&#39;:
                s_name = &#39;I&#39; + str(interval)
                c_interval = s_name
            else:
                s_name = s_type.replace(&#39;_&#39;, &#39;&#39;).replace(&#39;2&#39;, &#39;M&#39;).replace(
                    &#39;3&#39;, &#39;Lh&#39;).replace(&#39;4&#39;, &#39;Lt&#39;).replace(
                    &#39;6&#39;, &#39;B1&#39;).replace(&#39;7&#39;, &#39;B2&#39;)
            if &#39;B&#39; in s_name:
                c_ratio = &#39;R&#39; + str(ratio)
                c_interval = &#39;I&#39; + str(interval)
            if not prev_name[0] == s_type[0]:
                stage_change.append(1)
                changes.append(0)
                change_idx.append(0)
            else:
                stage_change.append(0)
                if not c_ratio == prev_ratio and not c_interval == prev_interval:
                    changes.append([c_ratio, c_interval])
                    change_idx.append(1)
                elif not c_ratio == prev_ratio:
                    changes.append(c_ratio)
                    change_idx.append(1)
                elif not c_interval == prev_interval:
                    changes.append(c_interval)
                    change_idx.append(1)
                elif not dpell_change == dpell_old:
                    changes.append(&#34;DPell&#34;)
                    change_idx.append(1)
                else:
                    changes.append(0)
                    change_idx.append(0)
            # Calculates total reward (y axis variable)
            r_list.append(len(pell_ts))

            # Calculates FR &amp; FI rewards and errors (alternative y axis variables)
            err_FI = 0
            err_FR = 0
            rw_FR = 0
            rw_FI = 0
            rw_double = 0
            err_plotted = 0
            corr_plotted = 0
            if s_type == &#39;7_&#39; or s_type == &#39;6_&#39;:
                norm_r_ts, _, norm_err_ts, norm_dr_ts, _ = s.split_sess(
                    all_levers=True)
                sch_type = s.get_arrays(&#39;Trial Type&#39;)
                if s_type == &#39;7_&#39;:
                    for i, _ in enumerate(norm_err_ts):
                        if sch_type[i] == 1:
                            err_FR = err_FR + len(norm_err_ts[i])
                        elif sch_type[i] == 0:
                            err_FI = err_FI + len(norm_err_ts[i])
                else:
                    err_FR = None
                    err_FI = None
                for i, _ in enumerate(norm_r_ts):
                    rw_double += len(norm_dr_ts[i])
                    if sch_type[i] == 1:
                        rw_FR = rw_FR + len(norm_r_ts[i])
                    elif sch_type[i] == 0:
                        rw_FI = rw_FI + len(norm_r_ts[i])
            elif s_type == &#39;5a&#39;:
                err_FI = None
                err_FR = None
                rw_FR = len(reward_times)
                rw_FI = None
                rw_double = None
            elif s_type == &#39;5b&#39;:
                err_FI = None
                err_FR = None
                rw_FR = None
                rw_FI = len(reward_times)
                rw_double = len(pell_double)

            else:
                err_FI = None
                err_FR = None
                rw_FR = None
                rw_FI = None
                rw_double = None

            # Updates list arrays with new session
            rw_FR_list.append(rw_FR)
            rw_FI_list.append(rw_FI)
            err_FR_list.append(err_FR)
            err_FI_list.append(err_FI)
            rw_double_list.append(rw_double)
            s_list.append(s_name)
            type_list.append(&#39;S-&#39; + s_type[0])

            # Updates current iteration variables for next loop
            dpell_old = dpell_change
            prev_ratio = c_ratio
            prev_interval = c_interval
            prev_name = s_type

        if single_plot:
            rows, cols = [1, 4]
            size_multiplier = 5
            fig = plt.figure(
                figsize=(cols * size_multiplier, rows * size_multiplier),
                tight_layout=False)
            gs = gridspec.GridSpec(rows, cols, wspace=0.2, hspace=0.3)
            ax = fig.add_subplot(gs[0, :])
            out_name = &#34;Timeline_&#34; + subject
            if recent:
                out_name += &#34;_recent&#34;
            if details:
                out_name += &#34;_details&#34;
        else:
            ax = fig.add_subplot(gs[int(c), :])

        s_idx = np.arange(0, len(s_list))

        if details:  # Plots average sessions variables i.e. FR_corr, FI_corr, FR_err, FI_err, double_rw
            ratio_c = plt.cm.get_cmap(&#39;Wistia&#39;)
            interval_c = plt.cm.get_cmap(&#39;winter&#39;)
            # Change value to increase height of annotation
            # note_height = 0
            # y_axis = np.zeros((1, len(s_idx)))[0] + note_height
            y_axis = []
            # Sets line on which annotations appear
            for i, l in enumerate(rw_FR_list):
                if l is None:
                    y_axis.append(0)  # Hides non-stage 7 annotations
                else:
                    y_axis.append(l)
            plots = []
            labels = []
            # Dict controls lines to be plot. Set keys to 1 in plot_dict to include line in plot
            if det_err:
                plot_styles = {
                    &#34;FR_Corr&#34;: [rw_FR_list, &#39;*-&#39;, ratio_c(3 * 45), 0],
                    &#34;FR_Err&#34;: [err_FR_list, &#39;x-&#39;, ratio_c(10 * 45), 1],
                    &#34;FI_Corr&#34;: [rw_FI_list, &#39;*-&#39;, interval_c(2 * 45), 0],
                    &#34;FI_Err&#34;: [err_FI_list, &#39;x-&#39;, interval_c(4 * 45), 1],
                    &#34;FI_DoubleR&#34;: [rw_double_list, &#39;*-&#39;, &#39;hotpink&#39;, 0]}
                err_plotted = 1
            elif det_corr:
                plot_styles = {
                    &#34;FR_Corr&#34;: [rw_FR_list, &#39;*-&#39;, ratio_c(3 * 45), 1],
                    &#34;FR_Err&#34;: [err_FR_list, &#39;x-&#39;, ratio_c(10 * 45), 0],
                    &#34;FI_Corr&#34;: [rw_FI_list, &#39;*-&#39;, interval_c(2 * 45), 1],
                    &#34;FI_Err&#34;: [err_FI_list, &#39;x-&#39;, interval_c(4 * 45), 0],
                    &#34;FI_DoubleR&#34;: [rw_double_list, &#39;*-&#39;, &#39;hotpink&#39;, 1]}
                corr_plotted = 1
            else:
                plot_styles = {
                    &#34;FR_Corr&#34;: [rw_FR_list, &#39;*-&#39;, ratio_c(3 * 45), 1],
                    &#34;FR_Err&#34;: [err_FR_list, &#39;x-&#39;, ratio_c(10 * 45), 1],
                    &#34;FI_Corr&#34;: [rw_FI_list, &#39;*-&#39;, interval_c(2 * 45), 1],
                    &#34;FI_Err&#34;: [err_FI_list, &#39;x-&#39;, interval_c(4 * 45), 1],
                    &#34;FI_DoubleR&#34;: [rw_double_list, &#39;*-&#39;, &#39;hotpink&#39;, 1]}
                err_plotted = 1
                corr_plotted = 1

            plot_dict = {&#34;FR_Corr&#34;: 1, &#34;FR_Err&#34;: 1,
                         &#34;FI_Corr&#34;: 1, &#34;FI_Err&#34;: 1, &#34;FI_DoubleR&#34;: 1}
            ax2 = ax.twinx()
            for k, val in plot_dict.items():
                if val:
                    s = plot_styles[k]
                    if k[-3:] == &#34;Err&#34;:
                        ax_used = ax2
                    else:
                        ax_used = ax
                    h, = ax_used.plot(s_idx, s[0], s[1], label=k, linewidth=&#39;2&#39;,
                                      markersize=10, color=s[2], alpha=s[3])
                    plots.append(h)
                    labels.append(h.get_label())
            ax.set_title(&#39;\nSubject {} Timeline_Details&#39;.format(
                subject), y=1.05, fontsize=25,
                color=bvmpc.bv_utils.mycolors(subject, sub_colors_dict))
        else:
            # Only plots total rewards
            y_axis = r_list
            h1, = plt.plot(
                s_idx, y_axis, label=&#39;Animal&#39; + subject, linewidth=&#39;4&#39;,
                color=bvmpc.bv_utils.mycolors(subject, sub_colors_dict))

            ax.set_title(
                &#39;\nSubject {} Timeline&#39;.format(subject), y=1.05, fontsize=25,
                color=bvmpc.bv_utils.mycolors(subject, sub_colors_dict))

            # # Plot experiment time w rewards
            # ax2 = ax.twinx()
            # y_axis_2 = time_list
            # ax2.set_ylim([0, 24])
            # ax2.plot(s_idx, y_axis_2, label=&#39;Animal&#39;+subject, linewidth=&#39;4&#39;,
            #                color=mycolors(subject))

        # Annotated changes in protocol
        annotate_fontsize = 12
        h2 = None
        h3 = None
        for i, c in enumerate(changes):
            if stage_change[i] == 1:
                h2 = ax.annotate(type_list[i], xy=(s_idx[i], y_axis[i]),
                                 ha=&#39;center&#39;, xytext=(0, (.2 * max(y_axis))),
                                 textcoords=&#39;offset points&#39;,
                                 arrowprops=dict(facecolor=&#39;blue&#39;, shrink=0.05), size=annotate_fontsize)
            elif change_idx[i] == 1:
                h3 = ax.annotate(str(c), xy=(s_idx[i], y_axis[i]),
                                 ha=&#39;center&#39;, xytext=(0, (.2 * max(y_axis))),
                                 textcoords=&#39;offset points&#39;,
                                 arrowprops=dict(facecolor=&#39;Red&#39;, shrink=0.05), size=annotate_fontsize)
        ax.set_xlim(0, len(s_idx))
        if show_date:
            # plots x-axis tics as dates
            plt.xticks(s_idx, d_list, fontsize=10)
            # plt.xticks(s_idx, box_list, fontsize=10)    # Plots x-tics as box
            ax.set_xlabel(&#39;Sessions (Dates)&#39;, fontsize=20)
        else:
            # plots x-axis ticks as stages
            plt.xticks(s_idx, s_list, fontsize=13)
            ax.set_xlabel(&#39;Sessions (Type)&#39;, fontsize=20)
        ax.spines[&#39;top&#39;].set_visible(False)
        ax.spines[&#39;right&#39;].set_visible(False)
        ax.tick_params(axis=&#39;y&#39;, labelsize=15)
        if details:
            if &#39;S-6&#39; in type_list:
                ax.axhline(45, xmax=(type_list.index(&#39;S-6&#39;) / len(type_list)), color=interval_c(2 * 45),
                           linestyle=&#39;-.&#39;, linewidth=&#39;.5&#39;)
                ax.axhline(30, xmin=(type_list.index(&#39;S-6&#39;) / len(type_list)), color=interval_c(2 * 45),
                           linestyle=&#39;-.&#39;, linewidth=&#39;.5&#39;)
                ax.text(type_list.index(&#39;S-6&#39;), 31, &#39; Max FI&#39;, fontsize=8,
                        color=interval_c(2 * 45), ha=&#39;left&#39;, va=&#39;bottom&#39;)
                ax.text(s_idx[0], 46, &#39; Max FI&#39;, fontsize=8,
                        color=interval_c(2 * 45), ha=&#39;left&#39;, va=&#39;bottom&#39;)
            else:
                ax.axhline(30, color=interval_c(2 * 45),
                           linestyle=&#39;-.&#39;, linewidth=&#39;.5&#39;)
                ax.text(s_idx[0], 31, &#39; Max FI&#39;, fontsize=8,
                        color=interval_c(2 * 45), ha=&#39;left&#39;, va=&#39;bottom&#39;)
            loc = &#39;top left&#39;
            ax.set_ylabel(&#39;Correct Trials&#39;, fontsize=20)
            # set second y-axis labels
            ax2.tick_params(axis=&#39;y&#39;, labelsize=15)
            ax2.set_ylabel(&#39;Error Presses&#39;, fontsize=20)
        else:
            # plt.axhline(45, color=&#39;g&#39;, linestyle=&#39;-.&#39;, linewidth=&#39;.5&#39;)
            plt.axhline(60, color=&#39;r&#39;, linestyle=&#39;-.&#39;,
                        linewidth=&#39;.5&#39;)  # Marks max reward
            ax.set_ylabel(&#39;Total Rewards&#39;, fontsize=20)
            plots = [h1]
            labels = [h1.get_label()]
            loc = &#39;lower right&#39;
        if h2 is not None and h3 is not None:
            plots.extend([h2.arrow_patch, h3.arrow_patch])
            labels.extend([&#39;Stage Changes&#39;, &#39;Protocol Mod.&#39;])
        elif h2 is not None:
            plots.append(h2.arrow_patch)
            labels.append(&#39;Stage Changes&#39;)
        elif h3 is not None:
            plots.append(h3.arrow_patch)
            labels.append(&#39;Protocol Mod.&#39;)
        plt.legend(plots, labels, loc=loc, ncol=2)
        if single_plot:
            out_name += &#34;.png&#34;
            print(&#34;Saved figure to {}&#34;.format(
                os.path.join(out_dir, out_name)))
            bv_plot.savefig(fig, os.path.join(out_dir, out_name))
            plt.close()

    if not single_plot:
        out_name = &#34;Timeline_Sum_&#34; + &#34;-&#34;.join(sub_list)
        if recent:
            out_name += &#34;_recent&#34;
        if details:
            out_name += &#34;_details&#34;
            if corr_plotted == 1 and err_plotted == 1:
                pass
            elif corr_plotted == 1:
                out_name += &#34;_corr&#34;
            elif err_plotted == 1:
                out_name += &#34;_err&#34;
        out_name += &#34;.png&#34;
        print(&#34;Saved figure to {}&#34;.format(
            os.path.join(out_dir, out_name)))
        bv_plot.savefig(fig, os.path.join(out_dir, out_name))
        plt.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="bvmpc.bv_batch.plot_batch_sessions"><code class="name flex">
<span>def <span class="ident">plot_batch_sessions</span></span>(<span>start_dir, sub_list, start_date, end_date, plt_flags, sub_colors_dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_batch_sessions(start_dir, sub_list, start_date, end_date, plt_flags, sub_colors_dict):
    out_dir = os.path.join(start_dir, &#34;Plots&#34;, &#34;Current&#34;)
    bvmpc.bv_utils.make_dir_if_not_exists(out_dir)

    if plt_flags[&#34;raster&#34;] == 1 or plt_flags[&#34;hist&#34;] == 1:
        # Path join only present in plot_sessions
        in_dir = os.path.join(start_dir, &#34;hdf5&#34;)

        # Default conversion of date based on start_date and end_date range
        d = []
        for single_date in bvmpc.bv_utils.daterange(start_date, end_date):
            d.append(single_date.isoformat()[-5:])

        print(&#39;Extracting sessions on {} for subjects {}...&#39;.format(d, sub_list))
        s_grp = extract_sessions(in_dir, sub_list, d_list=d)

        # splits s_grp into groups of 4
        plot_set = bvmpc.bv_utils.chunks(s_grp, 4)

        for j, plot_grp in enumerate(plot_set):
            # Figure Initialization
            n = len(plot_grp)
            if n &gt; 4:
                print(&#39;Too many plots&#39;)
                quit()
            elif n &gt; 2:
                rows, cols = [4, 4 * math.ceil(n / 2)]
            else:
                rows, cols = [2 * n, 4 * math.ceil(n / 2)]

            # Initializes GridFig Obj
            gf = bv_plot.GridFig(rows, cols, wspace=0.5, hspace=0.5)
            # fig = gf.get_fig()
            # size_multiplier = 5
            # fig = plt.figure(
            #     figsize=(cols * size_multiplier, rows * size_multiplier),
            #     tight_layout=False)
            # gs = gridspec.GridSpec(rows, cols, wspace=0.5, hspace=0.5)

            df_sub, df_date, df_stage = [], [], []  # Initialize plot naming parameters

            plotting_sub = []
            for i, s in enumerate(plot_grp):  # Iterate through groups to plot rasters
                # plot naming parameters
                df_sub.append(s.get_metadata(&#39;subject&#39;))
                df_date.append(s.get_metadata(
                    &#39;start_date&#39;).replace(&#39;/&#39;, &#39;_&#39;)[:5])
                df_stage.append(s.get_stage())

                # 2x2 plotting axes
                k = (i % 2) * 2
                if plt_flags[&#34;raster&#34;] == 1:
                    ax = gf.get_multi_ax(
                        k, k + 2, 4 * int(i / 2), 4 * math.ceil((i + 1) / 2))
                    bv_an.plot_raster_trials(
                        s, ax, sub_colors_dict, align=[0, 0, 1, 0])
                    plot_type = &#39;Raster_&#39;  # Plot name for saving

                if plt_flags[&#34;hist&#34;] == 1:
                    if not plotting_sub == s.get_metadata(&#39;subject&#39;):
                        ax = gf.get_multi_ax(
                            k, k + 2, 4 * int(i / 2), 4 * math.ceil((i + 1) / 2))
                        plotting_sub = s.get_metadata(&#39;subject&#39;)
                        loop = 1
                    bv_an.trial_length_hist(s, ax, loop, sub_colors_dict)
                    plot_type = &#39;Hist_&#39;  # Plot name for saving
                    loop += 1

            # Save Figure
            # plt.subplots_adjust(top=0.85)
            # fig.suptitle((&#39;Subject &#39; + subject + &#39; Performance&#39;),
            #                 color=mycolors(subject), fontsize=30)

            # date_p = sorted(set(df_date))
            # sub_p = sorted(set(df_sub))
            # stage_p = sorted(set(df_stage))
            # out_name = plot_type + str(date_p) + &#39;_&#39; + str(sub_p) + &#39;_&#39; + str(stage_p) + &#39;_&#39; + str(j)
            # out_name += &#34;.png&#34;
            # print(&#34;Saved figure to {}&#34;.format(
            #     os.path.join(out_dir, out_name)))
            # bv_plot.savefig(fig, os.path.join(out_dir, out_name))
            # plt.close()
            gf.save_fig(df_date, df_sub, df_stage, plot_type, out_dir, j)

    # plot cumulative response graphs
    if plt_flags[&#34;summary&#34;] == 1:
        for single_date in bvmpc.bv_utils.daterange(start_date, end_date):
            d = [single_date.isoformat()[-5:]]
            # plot_sessions(start_dir, d, sub, summary=True, single=True,
            #               corr_only=True, scd=sub_colors_dict)  # Single animal breakdown
            # Group with corr_only breakdown
            plot_sessions(start_dir, d, sub_list, summary=True,
                          single=False, corr_only=True, scd=sub_colors_dict)
            # plot_sessions(start_dir, d, sub, summary=True, single=False, corr_only=False, scd=sub_colors_dict)  # Group with complete breakdown

        # plot all 4 timeline types
    if plt_flags[&#34;timeline&#34;] == 1:
        print(&#34;Plotting Timeline...&#34;)
        d = [end_date.isoformat()[-5:]]
        in_dir = os.path.join(start_dir, &#34;hdf5&#34;)
        single = False  # plots seperate graphs for each animal if True
        show_date = True  # Sets x-axis as dates if True
        details = False
        recent = False
        if not single:
            plot_limit = 4
            sub_list = bvmpc.bv_utils.split_list(sub_list, plot_limit)
            for l in sub_list:
                timeline_plot(l, in_dir, out_dir, single_plot=single, det_err=False, det_corr=False,
                              recent=recent, show_date=show_date, details=details, sub_colors_dict=sub_colors_dict)
        else:
            # Plots timeline for specified subjects
            timeline_plot(sub_list, in_dir, out_dir, single_plot=single, det_err=False, det_corr=False,
                          recent=recent, show_date=show_date, details=details, sub_colors_dict=sub_colors_dict)</code></pre>
</details>
</dd>
<dt id="bvmpc.bv_batch.plot_sessions"><code class="name flex">
<span>def <span class="ident">plot_sessions</span></span>(<span>start_dir, d_list, sub_list, summary=False, single=False, timeline=False, details=False, det_err=False, det_corr=False, recent=False, show_date=False, int_only=False, corr_only=False, scd=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots session summaries
summary : bool, False
Optional. Plots all sessions in a single plot, up to 6
single : bool, False
Optional. Plots single session summaries with breakdown of single blocks
int_only : bool, False
Optional. Plots only interval trials in zoomed schedule plot
corr_only : bool, False
Optional. Plots seperate summary plot with correct only trials
scd : dict, None
dict of Sub : color
Used to assign color to plot title.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_sessions(
        start_dir, d_list, sub_list,
        summary=False, single=False, timeline=False,
        details=False, det_err=False, det_corr=False,
        recent=False, show_date=False, int_only=False,
        corr_only=False, scd=None):  # TODO Split timeline and plotting into seperate functions
    &#39;&#39;&#39; Plots session summaries
    summary : bool, False
        Optional. Plots all sessions in a single plot, up to 6
    single : bool, False
        Optional. Plots single session summaries with breakdown of single blocks
    int_only : bool, False
        Optional. Plots only interval trials in zoomed schedule plot
    corr_only : bool, False
        Optional. Plots seperate summary plot with correct only trials
    scd : dict, None
        dict of Sub : color
        Used to assign color to plot title.
    &#39;&#39;&#39;
    s_list = [&#39;4&#39;, &#39;5a&#39;, &#39;5b&#39;, &#39;6&#39;, &#39;7&#39;]

    in_dir = os.path.join(start_dir, &#34;hdf5&#34;)
    out_dir = os.path.join(start_dir, &#34;Plots&#34;, &#34;Current&#34;)
    bvmpc.bv_utils.make_dir_if_not_exists(out_dir)

    if summary and not corr_only:
        #  extracts hdf5 session based on specification
        max_plot = 4  # Set max plots per figure
        s_grp = extract_sessions(in_dir, sub_list, s_list, d_list)
        if s_grp == []:
            return print(&#34;***No Files Extracted***&#34;)
        idx = 0
        if len(s_grp) &gt; max_plot:
            j = 0
            s_grp_split = []
            s_grp_idx = np.arange(len(s_grp))
            for i in s_grp_idx[max_plot - 1::max_plot]:
                s_grp_split.append(s_grp[j:i + 1])
                j = i + 1

            mv = len(s_grp) % max_plot
            if mv != 0:
                s_grp_split.append(s_grp[-mv:])
            for s_grp in s_grp_split:
                idx += 1
                sum_plot(s_grp, idx, out_dir)
        else:
            sum_plot(s_grp, idx, out_dir)

    if summary and corr_only:
        # plots corr_only plots
        max_plot = 4  # Set max plots per figure
        s_grp = extract_sessions(in_dir, sub_list, s_list, d_list)
        if s_grp == []:
            return print(&#34;***No Files Extracted***&#34;)

        idx = 0
        if len(s_grp) &gt; max_plot:
            j = 0
            s_grp_split = []
            s_grp_idx = np.arange(len(s_grp))
            for i in s_grp_idx[max_plot - 1::max_plot]:
                s_grp_split.append(s_grp[j:i + 1])
                j = i + 1

            mv = len(s_grp) % max_plot
            if mv != 0:
                s_grp_split.append(s_grp[-mv:])
            for s_grp in s_grp_split:
                idx += 1
                sum_plot(s_grp, idx, out_dir, corr_only=True)
        else:
            sum_plot(s_grp, idx, out_dir, corr_only=True)

    if single and summary:
        # Single Subject Plots
        idx = 0
        for sub in sub_list:
            s_grp = extract_sessions(in_dir, sub, s_list, d_list)
            if s_grp == []:
                return print(&#34;***No Files Extracted***&#34;)
            s_passed = []
            d_passed = []
            for s in s_grp:
                stage = s.get_metadata(&#39;name&#39;)[:2].replace(&#39;_&#39;, &#39;&#39;)
                s_passed.append(stage)
                date = s.get_metadata(&#34;start_date&#34;).replace(&#34;/&#34;, &#34;-&#34;)
                d_passed.append(date[:5])
                subject = s.get_metadata(&#39;subject&#39;)
            if &#39;7&#39; in s_passed:
                gf = bv_plot.GridFig(len(s_grp), 4)
                fig = gf.get_fig()
                if len(s_grp) == 1:
                    fig.tight_layout(rect=[0, 0.03, 0.8, 0.95])
                for i, s in enumerate(s_grp):
                    ax1 = gf.get_next()
                    bv_an.cumplot(s, out_dir, ax1, int_only,
                                  zoom=False, zoom_sch=False)
                    ax2 = gf.get_next()
                    bv_an.cumplot(s, out_dir, ax2, int_only, zoom=False, zoom_sch=True,
                                  plot_error=False, plot_all=True)
                    ax3 = gf.get_next()
                    bv_an.cumplot(s, out_dir, ax3, int_only, zoom=False, zoom_sch=True,
                                  plot_error=False, plot_all=False)
                    ax4 = gf.get_next()
                    bv_an.cumplot(s, out_dir, ax4, int_only, zoom=False, zoom_sch=True,
                                  plot_error=True, plot_all=False)
                plt.subplots_adjust(top=0.85)
                if scd == None:
                    color = &#34;k&#34;
                else:
                    color = bvmpc.bv_utils.mycolors(sub, scd)
                fig.suptitle((&#39;Subject &#39; + subject + &#39; Performance&#39;),
                             color=color, fontsize=30)

                # # Seperate plots w line
                # ax1.hlines(1.13, -0, 4.9, clip_on=False,
                #             transform=ax1.transAxes, linewidth=0.7)
                s_print = np.array_str(np.unique(np.array(s_passed)))
                d_print = np.array_str(np.unique(np.array(d_passed)))
                out_name = &#34;Sum_&#34; + subject + &#34;_&#34; + d_print + &#34;_&#34; + s_print + &#34;.png&#34;
                bv_plot.savefig(fig, os.path.join(out_dir, out_name))
            else:
                sum_plot(s_grp, idx, out_dir, single=single)</code></pre>
</details>
</dd>
<dt id="bvmpc.bv_batch.struc_timeline"><code class="name flex">
<span>def <span class="ident">struc_timeline</span></span>(<span>sub_list, in_dir)</span>
</code></dt>
<dd>
<div class="desc"><p>Structure sessions into a pandas dataframe based on trials
Returns 2 outputs: grp_timeline_df, time_df_sub
grp_timeline_df - array of pandas dataframe across time based on session
grp_timeline_df_sub
- list denoting subject corresponding to each df</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def struc_timeline(sub_list, in_dir):
    &#34;&#34;&#34; Structure sessions into a pandas dataframe based on trials
    Returns 2 outputs: grp_timeline_df, time_df_sub
        grp_timeline_df - array of pandas dataframe across time based on session
        grp_timeline_df_sub     - list denoting subject corresponding to each df
    &#34;&#34;&#34;
    # Initialize group variables
    grp_timeline_df = []
    grp_timeline_df_sub = []

    for sub in sub_list:
        s_grp = extract_sessions(in_dir, sub)
        # Initialize column arrays
        d_list, t_list, sub_list, s_idx_list, r_list, s_list = [], [], [], [], [], []
        err_FR_list, err_FI_list = [], []
        rw_FR_list, rw_FI_list, dr_list = [], [], []
        ratio_list, interval_list = [], []
        sch_list, sch_rw_list, sch_err_list, sch_dr_list = [], [], [], []

        for i, s in enumerate(s_grp):
            subject = s.get_metadata(&#39;subject&#39;)
            date = s.get_metadata(&#34;start_date&#34;).replace(&#34;/&#34;, &#34;-&#34;)[:5]
            session_type = s.get_metadata(&#39;name&#39;)
            time = s.get_metadata(&#39;start_time&#39;)
            stage = session_type[:2].replace(
                &#39;_&#39;, &#39;&#39;)  # Obtain stage number w/o _
            timestamps = s.get_arrays()
            pell_ts = timestamps[&#34;Reward&#34;]
            dpell_bool = np.diff(pell_ts) &lt; 0.5
            dpell_idx = np.nonzero(dpell_bool)[0]
            reward_times = s.get_rw_ts()

            # Initialize variables used per session
            ratio, interval, sch, sch_err, sch_rw, sch_dr = [], [], [], [], [], []
            err_FI, err_FR, rw_FI, rw_FR = [], [], [], []

            ratio = s.get_ratio()
            interval = s.get_interval()
            # Stage specific variables
            if stage == &#39;5a&#39;:
                s_name = &#39;R&#39; + str(ratio)
                ratio = s_name
                rw_FR = len(reward_times)
            elif stage == &#39;5b&#39;:
                s_name = &#39;I&#39; + str(interval)
                interval = s_name
                rw_FI = len(reward_times)
            else:
                s_name = stage.replace(&#39;_&#39;, &#39;&#39;).replace(&#39;2&#39;, &#39;M&#39;).replace(
                    &#39;3&#39;, &#39;Lh&#39;).replace(&#39;4&#39;, &#39;Lt&#39;).replace(
                    &#39;6&#39;, &#39;B1&#39;).replace(&#39;7&#39;, &#39;B2&#39;)
            if &#39;B&#39; in s_name:
                rw_FI, rw_FR = 0, 0
                ratio = &#39;R&#39; + str(ratio)
                interval = &#39;I&#39; + str(interval)
                norm_r_ts, _, norm_err_ts, norm_dr_ts, _ = s.split_sess(
                    all_levers=True)
                sch_type = s.get_arrays(&#39;Trial Type&#39;)
                # Error related variables
                if s_name == &#39;B2&#39;:
                    err_FI, err_FR = 0, 0
                    for i, err in enumerate(norm_err_ts):
                        if sch_type[i] == 1:
                            err_FR = + len(err)
                        elif sch_type[i] == 0:
                            err_FI += len(err)
                        sch_err.append(len(err))
                else:
                    err_FR = []
                    err_FI = []

                # Reward related variables
                for i, (rw, dr) in enumerate(zip(norm_r_ts, norm_dr_ts)):
                    if sch_type[i] == 1:
                        rw_FR += len(rw)
                        sch.append(&#39;FR&#39;)
                        sch_dr.append([])
                    elif sch_type[i] == 0:
                        rw_FI += len(rw)
                        sch.append(&#39;FI&#39;)
                        sch_dr.append(len(dr))
                    sch_rw.append(len(rw))

            # Update list arrays with new session
            d_list.append(date)
            t_list.append(time)
            s_idx_list.append(&#39;S&#39; + stage[0])
            s_list.append(s_name)
            r_list.append(len(pell_ts))
            dr_list.append(len(dpell_idx))
            interval_list.append(interval)
            ratio_list.append(ratio)
            sch_list.append(sch)
            sch_rw_list.append(sch_rw)
            sch_err_list.append(sch_err)
            sch_dr_list.append(sch_dr)
            rw_FI_list.append(rw_FI)
            rw_FR_list.append(rw_FR)
            err_FI_list.append(err_FI)
            err_FR_list.append(err_FR)
        sub_list = np.full(len(d_list), sub, dtype=int)

        timeline_dict = {
            &#39;Subject&#39;: sub_list,
            &#39;Date&#39;: d_list,
            &#39;Start Time&#39;: t_list,
            &#39;Stage Idx&#39;: s_idx_list,  # eg. S2, S5, S7 ...
            &#39;Stage&#39;: s_list,  # eg. M, Lt, R8, I30, B1
            &#39;Total Rewards&#39;: r_list,
            &#39;Double Rewards&#39;: dr_list,
            &#39;Interval&#39;: interval_list,
            &#39;Ratio&#39;: ratio_list,
            &#39;Schedule Blocks&#39;: sch_list,
            &#39;Schedule Rw&#39;: sch_rw_list,
            &#39;Schedule Err&#39;: sch_err_list,
            &#39;Schedule DRw&#39;: sch_dr_list,
            &#39;FI Corr&#39;: rw_FI_list,
            &#39;FR Corr&#39;: rw_FR_list,
            &#39;FI Err&#39;: err_FI_list,
            &#39;FR Err&#39;: err_FR_list
        }
        timeline_df = pd.DataFrame(timeline_dict)
        grp_timeline_df.append(timeline_df)
        grp_timeline_df_sub.append(subject)

    return grp_timeline_df, grp_timeline_df_sub</code></pre>
</details>
</dd>
<dt id="bvmpc.bv_batch.sum_plot"><code class="name flex">
<span>def <span class="ident">sum_plot</span></span>(<span>s_grp, idx, out_dir, zoom=True, single=False, int_only=False, corr_only=False)</span>
</code></dt>
<dd>
<div class="desc"><p>zoom:
if True, divides session into blocks and plots each block as individual lines.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum_plot(s_grp, idx, out_dir, zoom=True, single=False,
             int_only=False, corr_only=False):
    &#34;&#34;&#34; zoom:   if True, divides session into blocks and plots each block as individual lines.

    &#34;&#34;&#34;
    # Plots summary of day
    if zoom:
        print(&#39;zoomed&#39;)
        if len(s_grp) &gt; 2:
            cols = 2 * math.ceil(len(s_grp) / 2)
            rows = 2
        else:
            rows = len(s_grp)
            cols = 2
    else:
        if len(s_grp) &gt; 4:
            rows = math.ceil(len(s_grp) / 4)
            cols = 4
        else:
            cols = len(s_grp)
            rows = 1
    gf = bv_plot.GridFig(rows, cols)
    fig = gf.get_fig()
    s_passed = []
    d_passed = []

    for _, s in enumerate(s_grp):
        subject = s.get_metadata(&#39;subject&#39;)
        stage = s.get_metadata(&#39;name&#39;)[:2].replace(&#39;_&#39;, &#39;&#39;)
        date = s.get_metadata(&#34;start_date&#34;).replace(&#34;/&#34;, &#34;-&#34;)
        s_passed.append(stage)
        d_passed.append(date[:5])

        if zoom:
            ax1 = gf.get_next_snake()
        else:
            ax1 = gf.get_next()

        if corr_only and stage == &#39;7&#39;:
            bv_an.cumplot(s, out_dir, ax1, int_only, zoom=False,
                          zoom_sch=False, plot_all=False)
        else:
            bv_an.cumplot(s, out_dir, ax1, int_only, zoom=False,
                          zoom_sch=False)

        if stage == &#39;2&#39; or stage == &#39;3&#39; or stage == &#39;4&#39;:
            IRT = True
        elif stage == &#39;5a&#39; or stage == &#39;5b&#39;:
            IRT = True  # Change to False for zoomed plot instead of IRT
        else:
            IRT = False

        if IRT:
            ax2 = gf.get_next_snake()
            bv_an.IRT(s, out_dir, ax2)
        elif zoom:
            ax2 = gf.get_next_snake()
            if corr_only and stage == &#39;7&#39;:
                bv_an.cumplot(s, out_dir, ax2, int_only, zoom=False, zoom_sch=True,
                              plot_error=False, plot_all=False)
            else:
                bv_an.cumplot(s, out_dir, ax2, int_only, zoom=False, zoom_sch=True,
                              plot_error=False, plot_all=True)
        plt.subplots_adjust(top=0.85)
    d_print = np.array_str(np.unique(np.array(d_passed)))
    d_title = np.array2string(np.unique(np.array(d_passed)))
    s_print = np.array_str(np.unique(np.array(s_passed)))

    if single:
        fig.suptitle((&#39;Subject &#39; + subject + &#39; Performance&#39;), fontsize=30)
        out_name = &#34;Sum_&#34; + subject + &#34;_&#34; + d_print + &#34;_&#34; + s_print + &#34;.png&#34;
    elif corr_only and stage == &#39;7&#39;:
        if idx == 0:
            fig.suptitle((&#39;Summary across animals &#39; + d_title +
                          &#39;_Correct Only&#39;), fontsize=30)
            out_name = &#34;Sum_&#34; + d_print + &#34;_&#34; + s_print + &#34;_Corr.png&#34;
        else:
            fig.suptitle((&#39;Summary across animals &#39; + d_title +
                          &#39;_Correct Only&#39; + &#34; p&#34; + str(idx)), fontsize=30)
            out_name = &#34;Sum_&#34; + d_print + &#34;_&#34; + \
                s_print + &#34;_&#34; + str(idx) + &#34;_Corr.png&#34;
    else:
        if idx == 0:
            fig.suptitle((&#39;Summary across animals &#39; + d_title), fontsize=30)
            out_name = &#34;Sum_&#34; + d_print + &#34;_&#34; + s_print + &#34;.png&#34;
        else:
            fig.suptitle((&#39;Summary across animals &#39; +
                          d_title + &#34; p&#34; + str(idx)), fontsize=30)
            out_name = &#34;Sum_&#34; + d_print + &#34;_&#34; + \
                s_print + &#34;_&#34; + str(idx) + &#34;.png&#34;
    print(&#34;Saved figure to {}&#34;.format(
        os.path.join(out_dir, out_name)))
    bv_plot.savefig(fig, os.path.join(out_dir, out_name))
    plt.close()</code></pre>
</details>
</dd>
<dt id="bvmpc.bv_batch.timeline_plot"><code class="name flex">
<span>def <span class="ident">timeline_plot</span></span>(<span>sub_list, in_dir, out_dir, single_plot=False, det_err=False, det_corr=False, recent=False, show_date=True, details=False, sub_colors_dict=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots total rewards from beginining of first session
</p>
<p>Arguments:
det_err - plots error lever presses
det_cor - plots correct lever presses
recent - plots recent (determined in code - static) datapoints only
show_date - plots date as x axis instead of session type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def timeline_plot(
        sub_list, in_dir, out_dir, single_plot=False,
        det_err=False, det_corr=False, recent=False,
        show_date=True, details=False, sub_colors_dict=None):
    &#34;&#34;&#34;

    Plots total rewards from beginining of first session  

    Arguments:
    det_err - plots error lever presses
    det_cor - plots correct lever presses
    recent - plots recent (determined in code - static) datapoints only
    show_date - plots date as x axis instead of session type
    &#34;&#34;&#34;
    # Plot size
    rows, cols = [len(sub_list), 4]
    size_multiplier = 5
    fig = plt.figure(
        figsize=(cols * size_multiplier, rows * size_multiplier),
        tight_layout=False)
    gs = gridspec.GridSpec(rows, cols, wspace=0.4, hspace=0.5)

    for c, sub in enumerate(sub_list):
        # Plot total pellets across sessions
        s_grp = extract_sessions(in_dir, [sub])
        s_list, r_list, type_list, d_list, box_list, time_list = [], [], [], [], [], []
        err_FR_list, err_FI_list = [], []
        rw_FR_list, rw_FI_list, rw_double_list = [], [], []
        changes, stage_change, dpell_change = [], [], []
        change_idx = []
        prev_ratio, prev_interval, c_ratio, c_interval = [], [], [], []
        dpell_old = []
        prev_name = &#39;2&#39;
        if recent:
            number_sessions_ago = -31  # change value to set number of sessions ago
            s_grp = s_grp[number_sessions_ago:]
        else:
            pass

        for i, s in enumerate(s_grp):
            ratio = s.get_ratio()
            interval = s.get_interval()
            s_type = s.get_metadata(&#39;name&#39;)[:2]
            timestamps = s.get_arrays()

            date = s.get_metadata(&#39;start_date&#39;)  # Display mm/dd/yy
            date = s.get_metadata(&#39;start_date&#39;)[:-3]  # Display mm/dd only
            # date = s.get_metadata(&#39;start_date&#39;).split(&#34;/&#34;)[1]  # Display dd only
            subject = s.get_metadata(&#39;subject&#39;)
            pell_ts = timestamps[&#34;Reward&#34;]
            pell_double = np.nonzero(np.diff(pell_ts) &lt; 0.5)[0]
            reward_times = s.get_rw_ts()
            box = s.get_metadata(&#39;box&#39;)
            # time format - &#34;%H:%M:%S&#34;
            exptime = s.get_metadata(&#39;start_time&#39;)[:2]

            d_list.append(date)
            box_list.append(box)
            time_list.append(exptime)

            if len(pell_double):
                dpell_change = 1
            if s_type == &#39;5a&#39;:
                s_name = &#39;R&#39; + str(ratio)
                c_ratio = s_name
            elif s_type == &#39;5b&#39;:
                s_name = &#39;I&#39; + str(interval)
                c_interval = s_name
            else:
                s_name = s_type.replace(&#39;_&#39;, &#39;&#39;).replace(&#39;2&#39;, &#39;M&#39;).replace(
                    &#39;3&#39;, &#39;Lh&#39;).replace(&#39;4&#39;, &#39;Lt&#39;).replace(
                    &#39;6&#39;, &#39;B1&#39;).replace(&#39;7&#39;, &#39;B2&#39;)
            if &#39;B&#39; in s_name:
                c_ratio = &#39;R&#39; + str(ratio)
                c_interval = &#39;I&#39; + str(interval)
            if not prev_name[0] == s_type[0]:
                stage_change.append(1)
                changes.append(0)
                change_idx.append(0)
            else:
                stage_change.append(0)
                if not c_ratio == prev_ratio and not c_interval == prev_interval:
                    changes.append([c_ratio, c_interval])
                    change_idx.append(1)
                elif not c_ratio == prev_ratio:
                    changes.append(c_ratio)
                    change_idx.append(1)
                elif not c_interval == prev_interval:
                    changes.append(c_interval)
                    change_idx.append(1)
                elif not dpell_change == dpell_old:
                    changes.append(&#34;DPell&#34;)
                    change_idx.append(1)
                else:
                    changes.append(0)
                    change_idx.append(0)
            # Calculates total reward (y axis variable)
            r_list.append(len(pell_ts))

            # Calculates FR &amp; FI rewards and errors (alternative y axis variables)
            err_FI = 0
            err_FR = 0
            rw_FR = 0
            rw_FI = 0
            rw_double = 0
            err_plotted = 0
            corr_plotted = 0
            if s_type == &#39;7_&#39; or s_type == &#39;6_&#39;:
                norm_r_ts, _, norm_err_ts, norm_dr_ts, _ = s.split_sess(
                    all_levers=True)
                sch_type = s.get_arrays(&#39;Trial Type&#39;)
                if s_type == &#39;7_&#39;:
                    for i, _ in enumerate(norm_err_ts):
                        if sch_type[i] == 1:
                            err_FR = err_FR + len(norm_err_ts[i])
                        elif sch_type[i] == 0:
                            err_FI = err_FI + len(norm_err_ts[i])
                else:
                    err_FR = None
                    err_FI = None
                for i, _ in enumerate(norm_r_ts):
                    rw_double += len(norm_dr_ts[i])
                    if sch_type[i] == 1:
                        rw_FR = rw_FR + len(norm_r_ts[i])
                    elif sch_type[i] == 0:
                        rw_FI = rw_FI + len(norm_r_ts[i])
            elif s_type == &#39;5a&#39;:
                err_FI = None
                err_FR = None
                rw_FR = len(reward_times)
                rw_FI = None
                rw_double = None
            elif s_type == &#39;5b&#39;:
                err_FI = None
                err_FR = None
                rw_FR = None
                rw_FI = len(reward_times)
                rw_double = len(pell_double)

            else:
                err_FI = None
                err_FR = None
                rw_FR = None
                rw_FI = None
                rw_double = None

            # Updates list arrays with new session
            rw_FR_list.append(rw_FR)
            rw_FI_list.append(rw_FI)
            err_FR_list.append(err_FR)
            err_FI_list.append(err_FI)
            rw_double_list.append(rw_double)
            s_list.append(s_name)
            type_list.append(&#39;S-&#39; + s_type[0])

            # Updates current iteration variables for next loop
            dpell_old = dpell_change
            prev_ratio = c_ratio
            prev_interval = c_interval
            prev_name = s_type

        if single_plot:
            rows, cols = [1, 4]
            size_multiplier = 5
            fig = plt.figure(
                figsize=(cols * size_multiplier, rows * size_multiplier),
                tight_layout=False)
            gs = gridspec.GridSpec(rows, cols, wspace=0.2, hspace=0.3)
            ax = fig.add_subplot(gs[0, :])
            out_name = &#34;Timeline_&#34; + subject
            if recent:
                out_name += &#34;_recent&#34;
            if details:
                out_name += &#34;_details&#34;
        else:
            ax = fig.add_subplot(gs[int(c), :])

        s_idx = np.arange(0, len(s_list))

        if details:  # Plots average sessions variables i.e. FR_corr, FI_corr, FR_err, FI_err, double_rw
            ratio_c = plt.cm.get_cmap(&#39;Wistia&#39;)
            interval_c = plt.cm.get_cmap(&#39;winter&#39;)
            # Change value to increase height of annotation
            # note_height = 0
            # y_axis = np.zeros((1, len(s_idx)))[0] + note_height
            y_axis = []
            # Sets line on which annotations appear
            for i, l in enumerate(rw_FR_list):
                if l is None:
                    y_axis.append(0)  # Hides non-stage 7 annotations
                else:
                    y_axis.append(l)
            plots = []
            labels = []
            # Dict controls lines to be plot. Set keys to 1 in plot_dict to include line in plot
            if det_err:
                plot_styles = {
                    &#34;FR_Corr&#34;: [rw_FR_list, &#39;*-&#39;, ratio_c(3 * 45), 0],
                    &#34;FR_Err&#34;: [err_FR_list, &#39;x-&#39;, ratio_c(10 * 45), 1],
                    &#34;FI_Corr&#34;: [rw_FI_list, &#39;*-&#39;, interval_c(2 * 45), 0],
                    &#34;FI_Err&#34;: [err_FI_list, &#39;x-&#39;, interval_c(4 * 45), 1],
                    &#34;FI_DoubleR&#34;: [rw_double_list, &#39;*-&#39;, &#39;hotpink&#39;, 0]}
                err_plotted = 1
            elif det_corr:
                plot_styles = {
                    &#34;FR_Corr&#34;: [rw_FR_list, &#39;*-&#39;, ratio_c(3 * 45), 1],
                    &#34;FR_Err&#34;: [err_FR_list, &#39;x-&#39;, ratio_c(10 * 45), 0],
                    &#34;FI_Corr&#34;: [rw_FI_list, &#39;*-&#39;, interval_c(2 * 45), 1],
                    &#34;FI_Err&#34;: [err_FI_list, &#39;x-&#39;, interval_c(4 * 45), 0],
                    &#34;FI_DoubleR&#34;: [rw_double_list, &#39;*-&#39;, &#39;hotpink&#39;, 1]}
                corr_plotted = 1
            else:
                plot_styles = {
                    &#34;FR_Corr&#34;: [rw_FR_list, &#39;*-&#39;, ratio_c(3 * 45), 1],
                    &#34;FR_Err&#34;: [err_FR_list, &#39;x-&#39;, ratio_c(10 * 45), 1],
                    &#34;FI_Corr&#34;: [rw_FI_list, &#39;*-&#39;, interval_c(2 * 45), 1],
                    &#34;FI_Err&#34;: [err_FI_list, &#39;x-&#39;, interval_c(4 * 45), 1],
                    &#34;FI_DoubleR&#34;: [rw_double_list, &#39;*-&#39;, &#39;hotpink&#39;, 1]}
                err_plotted = 1
                corr_plotted = 1

            plot_dict = {&#34;FR_Corr&#34;: 1, &#34;FR_Err&#34;: 1,
                         &#34;FI_Corr&#34;: 1, &#34;FI_Err&#34;: 1, &#34;FI_DoubleR&#34;: 1}
            ax2 = ax.twinx()
            for k, val in plot_dict.items():
                if val:
                    s = plot_styles[k]
                    if k[-3:] == &#34;Err&#34;:
                        ax_used = ax2
                    else:
                        ax_used = ax
                    h, = ax_used.plot(s_idx, s[0], s[1], label=k, linewidth=&#39;2&#39;,
                                      markersize=10, color=s[2], alpha=s[3])
                    plots.append(h)
                    labels.append(h.get_label())
            ax.set_title(&#39;\nSubject {} Timeline_Details&#39;.format(
                subject), y=1.05, fontsize=25,
                color=bvmpc.bv_utils.mycolors(subject, sub_colors_dict))
        else:
            # Only plots total rewards
            y_axis = r_list
            h1, = plt.plot(
                s_idx, y_axis, label=&#39;Animal&#39; + subject, linewidth=&#39;4&#39;,
                color=bvmpc.bv_utils.mycolors(subject, sub_colors_dict))

            ax.set_title(
                &#39;\nSubject {} Timeline&#39;.format(subject), y=1.05, fontsize=25,
                color=bvmpc.bv_utils.mycolors(subject, sub_colors_dict))

            # # Plot experiment time w rewards
            # ax2 = ax.twinx()
            # y_axis_2 = time_list
            # ax2.set_ylim([0, 24])
            # ax2.plot(s_idx, y_axis_2, label=&#39;Animal&#39;+subject, linewidth=&#39;4&#39;,
            #                color=mycolors(subject))

        # Annotated changes in protocol
        annotate_fontsize = 12
        h2 = None
        h3 = None
        for i, c in enumerate(changes):
            if stage_change[i] == 1:
                h2 = ax.annotate(type_list[i], xy=(s_idx[i], y_axis[i]),
                                 ha=&#39;center&#39;, xytext=(0, (.2 * max(y_axis))),
                                 textcoords=&#39;offset points&#39;,
                                 arrowprops=dict(facecolor=&#39;blue&#39;, shrink=0.05), size=annotate_fontsize)
            elif change_idx[i] == 1:
                h3 = ax.annotate(str(c), xy=(s_idx[i], y_axis[i]),
                                 ha=&#39;center&#39;, xytext=(0, (.2 * max(y_axis))),
                                 textcoords=&#39;offset points&#39;,
                                 arrowprops=dict(facecolor=&#39;Red&#39;, shrink=0.05), size=annotate_fontsize)
        ax.set_xlim(0, len(s_idx))
        if show_date:
            # plots x-axis tics as dates
            plt.xticks(s_idx, d_list, fontsize=10)
            # plt.xticks(s_idx, box_list, fontsize=10)    # Plots x-tics as box
            ax.set_xlabel(&#39;Sessions (Dates)&#39;, fontsize=20)
        else:
            # plots x-axis ticks as stages
            plt.xticks(s_idx, s_list, fontsize=13)
            ax.set_xlabel(&#39;Sessions (Type)&#39;, fontsize=20)
        ax.spines[&#39;top&#39;].set_visible(False)
        ax.spines[&#39;right&#39;].set_visible(False)
        ax.tick_params(axis=&#39;y&#39;, labelsize=15)
        if details:
            if &#39;S-6&#39; in type_list:
                ax.axhline(45, xmax=(type_list.index(&#39;S-6&#39;) / len(type_list)), color=interval_c(2 * 45),
                           linestyle=&#39;-.&#39;, linewidth=&#39;.5&#39;)
                ax.axhline(30, xmin=(type_list.index(&#39;S-6&#39;) / len(type_list)), color=interval_c(2 * 45),
                           linestyle=&#39;-.&#39;, linewidth=&#39;.5&#39;)
                ax.text(type_list.index(&#39;S-6&#39;), 31, &#39; Max FI&#39;, fontsize=8,
                        color=interval_c(2 * 45), ha=&#39;left&#39;, va=&#39;bottom&#39;)
                ax.text(s_idx[0], 46, &#39; Max FI&#39;, fontsize=8,
                        color=interval_c(2 * 45), ha=&#39;left&#39;, va=&#39;bottom&#39;)
            else:
                ax.axhline(30, color=interval_c(2 * 45),
                           linestyle=&#39;-.&#39;, linewidth=&#39;.5&#39;)
                ax.text(s_idx[0], 31, &#39; Max FI&#39;, fontsize=8,
                        color=interval_c(2 * 45), ha=&#39;left&#39;, va=&#39;bottom&#39;)
            loc = &#39;top left&#39;
            ax.set_ylabel(&#39;Correct Trials&#39;, fontsize=20)
            # set second y-axis labels
            ax2.tick_params(axis=&#39;y&#39;, labelsize=15)
            ax2.set_ylabel(&#39;Error Presses&#39;, fontsize=20)
        else:
            # plt.axhline(45, color=&#39;g&#39;, linestyle=&#39;-.&#39;, linewidth=&#39;.5&#39;)
            plt.axhline(60, color=&#39;r&#39;, linestyle=&#39;-.&#39;,
                        linewidth=&#39;.5&#39;)  # Marks max reward
            ax.set_ylabel(&#39;Total Rewards&#39;, fontsize=20)
            plots = [h1]
            labels = [h1.get_label()]
            loc = &#39;lower right&#39;
        if h2 is not None and h3 is not None:
            plots.extend([h2.arrow_patch, h3.arrow_patch])
            labels.extend([&#39;Stage Changes&#39;, &#39;Protocol Mod.&#39;])
        elif h2 is not None:
            plots.append(h2.arrow_patch)
            labels.append(&#39;Stage Changes&#39;)
        elif h3 is not None:
            plots.append(h3.arrow_patch)
            labels.append(&#39;Protocol Mod.&#39;)
        plt.legend(plots, labels, loc=loc, ncol=2)
        if single_plot:
            out_name += &#34;.png&#34;
            print(&#34;Saved figure to {}&#34;.format(
                os.path.join(out_dir, out_name)))
            bv_plot.savefig(fig, os.path.join(out_dir, out_name))
            plt.close()

    if not single_plot:
        out_name = &#34;Timeline_Sum_&#34; + &#34;-&#34;.join(sub_list)
        if recent:
            out_name += &#34;_recent&#34;
        if details:
            out_name += &#34;_details&#34;
            if corr_plotted == 1 and err_plotted == 1:
                pass
            elif corr_plotted == 1:
                out_name += &#34;_corr&#34;
            elif err_plotted == 1:
                out_name += &#34;_err&#34;
        out_name += &#34;.png&#34;
        print(&#34;Saved figure to {}&#34;.format(
            os.path.join(out_dir, out_name)))
        bv_plot.savefig(fig, os.path.join(out_dir, out_name))
        plt.close()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="bvmpc" href="index.html">bvmpc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="bvmpc.bv_batch.plot_batch_sessions" href="#bvmpc.bv_batch.plot_batch_sessions">plot_batch_sessions</a></code></li>
<li><code><a title="bvmpc.bv_batch.plot_sessions" href="#bvmpc.bv_batch.plot_sessions">plot_sessions</a></code></li>
<li><code><a title="bvmpc.bv_batch.struc_timeline" href="#bvmpc.bv_batch.struc_timeline">struc_timeline</a></code></li>
<li><code><a title="bvmpc.bv_batch.sum_plot" href="#bvmpc.bv_batch.sum_plot">sum_plot</a></code></li>
<li><code><a title="bvmpc.bv_batch.timeline_plot" href="#bvmpc.bv_batch.timeline_plot">timeline_plot</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>